{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>StormWeaver is a concurrent database testing tool, inspired by PStress.</p> <p>It has two goals:</p> <ul> <li>Provide a framework for writing highly concurrent, somewhat randomized tests to stress the database server and uncover synchronization/locking/memory management issues</li> <li>Provide a framework for writing complex test scenarios in a user-friendly format (TODO)</li> </ul> <p>Currently it works with PostgreSQL and is used for testing <code>pg_tde</code>.</p>"},{"location":"#installation","title":"Installation","text":"<p>For now, there are no prebuilt packages. StormWeaver has to be built from source.</p> <p>See Building from source for details.</p>"},{"location":"#a-first-scenario","title":"A first scenario","text":"<p>StormWeaver stores test scenarios in the <code>scenarios</code> folder, written in Lua. There is a scenario called <code>basic</code> with lots of comments intended as a first example. To run it, execute the following command:</p> <pre><code>cd stormweaver\nbin/stormweaver scenarios/basic.lua [-c config/stormweaver.toml] [-i /path/to/the/pg/folder/] [scenario specific arguments...]\n</code></pre> <p>This script will:</p> <ol> <li>Set up a new data directory in <code>datadirs/datadir_pr/...</code></li> <li>Start PostgreSQL with this data directory</li> <li>Unless the <code>WITHOUT_TDE</code> environment variable is defined, configure <code>pg_tde</code></li> <li>Start the server instance</li> <li>Create normal or encrypted tables based on the above setting</li> <li>Run a 20-second workload on the server, repeating 10 times.    Each time it randomly restarts the server or sends a <code>kill -9</code> signal.</li> </ol>"},{"location":"#whats-next","title":"What's next?","text":"<p>More details about the use of StormWeaver can be found in the following sections:</p> <ol> <li>A quick high-level overview of how the project is constructed from a user's perspective</li> <li>The configuration options supported by the default scripting framework</li> <li>What functions are available in the scenario scripts</li> </ol>"},{"location":"adr-enhanced-statistics/","title":"ADR: Enhanced Statistics System for StormWeaver","text":""},{"location":"adr-enhanced-statistics/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr-enhanced-statistics/#context","title":"Context","text":"<p>StormWeaver currently provides minimal per-worker statistics, only tracking the total number of successful and failed actions. This limited visibility makes it difficult to: - Identify which specific action types are causing failures - Distinguish between different types of errors (logic errors vs SQL errors) - Measure performance characteristics like execution times - Monitor system behavior during long-running tests</p>"},{"location":"adr-enhanced-statistics/#decision","title":"Decision","text":"<p>Implement a comprehensive worker-level statistics system that provides detailed metrics collection and reporting.</p>"},{"location":"adr-enhanced-statistics/#overview-of-functionality","title":"Overview of Functionality","text":"<p>Create an enhanced statistics system that replaces the current minimal success/failure counters with detailed per-action-type metrics, comprehensive error categorization, and timing measurements at the worker level.</p>"},{"location":"adr-enhanced-statistics/#files-to-be-created","title":"Files to be Created","text":"<ul> <li><code>libstormweaver/include/statistics.hpp</code> - Statistics data structures and interfaces</li> <li><code>libstormweaver/src/statistics.cpp</code> - Statistics implementation</li> <li><code>libstormweaver/test/unit/statistics_test.cpp</code> - Unit tests for statistics system</li> </ul>"},{"location":"adr-enhanced-statistics/#files-to-be-modified","title":"Files to be Modified","text":"<ul> <li><code>libstormweaver/include/workload.hpp</code> - Add enhanced statistics structures</li> <li><code>libstormweaver/src/workload.cpp</code> - Implement statistics collection in workers</li> <li><code>libstormweaver/include/action/action.hpp</code> - Add timing and error code interfaces</li> <li><code>libstormweaver/src/action/action.cpp</code> - Implement error codes and timing</li> <li><code>libstormweaver/include/action/action_registry.hpp</code> - Enhance exception classes</li> <li><code>libstormweaver/src/action/action_registry.cpp</code> - Add error code handling</li> <li><code>libstormweaver/include/sql_variant/generic.hpp</code> - Add error codes to SqlException</li> <li><code>libstormweaver/src/sql_variant/generic.cpp</code> - Implement error code mapping</li> </ul>"},{"location":"adr-enhanced-statistics/#design-decisions","title":"Design Decisions","text":""},{"location":"adr-enhanced-statistics/#1-data-structure-design","title":"1. Data Structure Design","text":"<ul> <li>Map-based storage: Use <code>std::unordered_map&lt;std::string, ActionStatistics&gt;</code> with ActionFactory names as keys</li> <li>Worker-level only: No thread safety concerns since workers are single-threaded</li> <li>Simple design: Statistics are local to each worker and reported independently</li> </ul>"},{"location":"adr-enhanced-statistics/#2-error-categorization","title":"2. Error Categorization","text":"<ul> <li>Three exception categories: ActionException, SqlException, and Other (generic std::exception)</li> <li>String-based error identifiers: SQL error codes as strings, ActionException error names as descriptive strings</li> <li>Separate tracking: Maintain separate maps for SQL error codes vs ActionException error names</li> <li>No backward compatibility: Update all exception throwing sites to include error codes/names</li> </ul>"},{"location":"adr-enhanced-statistics/#3-timing-measurements","title":"3. Timing Measurements","text":"<ul> <li>Dual timing: Measure both overall action execution time and SQL server query time</li> <li>High precision: Use <code>std::chrono::high_resolution_clock</code> for nanosecond precision</li> <li>Simple aggregation: Track min, max, mean for each action type</li> </ul>"},{"location":"adr-enhanced-statistics/#4-performance-considerations","title":"4. Performance Considerations","text":"<ul> <li>Minimal overhead: Use efficient containers and minimize string allocations</li> <li>Single-threaded: No locking or atomic operations needed</li> <li>Local collection: All statistics operations are local to worker thread</li> </ul>"},{"location":"adr-enhanced-statistics/#architecture","title":"Architecture","text":""},{"location":"adr-enhanced-statistics/#core-components","title":"Core Components","text":"<pre><code>// Per-action statistics within a worker\nstruct ActionStatistics {\n    uint64_t successCount = 0;\n    uint64_t actionFailureCount = 0;     // ActionException\n    uint64_t sqlFailureCount = 0;        // SqlException\n    uint64_t otherFailureCount = 0;      // Any other exception\n\n    // Error categorization (separate maps for different error types)\n    std::map&lt;std::string, uint64_t&gt; actionErrorNames;  // ActionException error names\n    std::map&lt;std::string, uint64_t&gt; sqlErrorCodes;     // SQL error codes\n\n    // Timing statistics\n    uint64_t totalExecutionTimeNs = 0;\n    uint64_t totalSqlTimeNs = 0;\n    uint64_t minExecutionTimeNs = UINT64_MAX;\n    uint64_t maxExecutionTimeNs = 0;\n    uint64_t minSqlTimeNs = UINT64_MAX;\n    uint64_t maxSqlTimeNs = 0;\n};\n\n// Worker-level statistics (replaces current simple counters)\nstruct WorkerStatistics {\n    std::unordered_map&lt;std::string, ActionStatistics&gt; actionStats;\n    std::chrono::steady_clock::time_point startTime;\n    std::chrono::steady_clock::time_point endTime;\n\n    // Methods for updating and reporting\n    void recordSuccess(const std::string&amp; actionName, uint64_t execTimeNs, uint64_t sqlTimeNs);\n    void recordActionFailure(const std::string&amp; actionName, const std::string&amp; errorName, uint64_t execTimeNs);\n    void recordSqlFailure(const std::string&amp; actionName, const std::string&amp; errorCode, uint64_t execTimeNs);\n    void recordOtherFailure(const std::string&amp; actionName, uint64_t execTimeNs);\n    void reset();\n    void report() const;\n};\n</code></pre>"},{"location":"adr-enhanced-statistics/#integration-points","title":"Integration Points","text":"<ol> <li>Worker Integration: Replace simple counters in <code>RandomWorker</code> with <code>WorkerStatistics</code></li> <li>Action Integration: Add timing wrapper around action execution</li> <li>Exception Integration: Enhance exception classes with error codes/names</li> <li>Reporting Integration: Update existing worker reporting to use detailed statistics</li> </ol>"},{"location":"adr-enhanced-statistics/#challenges-encountered","title":"Challenges Encountered","text":""},{"location":"adr-enhanced-statistics/#1-exception-handling-complexity","title":"1. Exception Handling Complexity","text":"<p>Challenge: Actions can throw any type of exception, not just ActionException or SqlException Solution: Implement exception categorization with three categories: ActionException, SqlException, and other generic exceptions</p>"},{"location":"adr-enhanced-statistics/#2-error-code-consistency","title":"2. Error Code Consistency","text":"<p>Challenge: Different error types need different identification schemes Solution: Use separate maps for ActionException error names and SQL error codes, simple count for other exceptions</p>"},{"location":"adr-enhanced-statistics/#3-breaking-changes","title":"3. Breaking Changes","text":"<p>Challenge: Updating all exception throwing sites without backward compatibility Solution: Systematically update all SqlException and ActionException throwing sites with appropriate error identifiers</p>"},{"location":"adr-enhanced-statistics/#solutions-implemented","title":"Solutions Implemented","text":""},{"location":"adr-enhanced-statistics/#1-simplified-exception-categorization","title":"1. Simplified Exception Categorization","text":"<ul> <li>ActionException with descriptive error names (e.g., \"invalid_table\", \"constraint_violation\")</li> <li>SqlException with string error codes from SQL server or hardcoded strings</li> <li>Other exceptions tracked with simple count (no error categorization)</li> </ul>"},{"location":"adr-enhanced-statistics/#2-string-based-error-identifiers","title":"2. String-Based Error Identifiers","text":"<ul> <li>Keep SQL error codes as strings (matching current implementation)</li> <li>Use descriptive string names for ActionException errors</li> <li>Simple count for other exception types</li> </ul>"},{"location":"adr-enhanced-statistics/#3-systematic-exception-updates","title":"3. Systematic Exception Updates","text":"<ul> <li>Update all SqlException throw sites to include error codes</li> <li>Update all ActionException throw sites to include error names</li> <li>No backward compatibility concerns since these are internal APIs</li> </ul>"},{"location":"adr-enhanced-statistics/#4-raii-timing","title":"4. RAII Timing","text":"<p>Implement timing measurement using RAII pattern to ensure accurate measurement even with exceptions</p>"},{"location":"adr-enhanced-statistics/#future-considerations","title":"Future Considerations","text":""},{"location":"adr-enhanced-statistics/#1-export-formats","title":"1. Export Formats","text":"<ul> <li>Add JSON and CSV export capabilities for external analysis</li> <li>Consider structured logging for statistics data</li> </ul>"},{"location":"adr-enhanced-statistics/#2-cross-worker-analysis","title":"2. Cross-Worker Analysis","text":"<ul> <li>If needed in the future, add utilities to aggregate statistics across workers</li> <li>Consider adding worker identification for correlation</li> </ul>"},{"location":"adr-enhanced-statistics/#3-advanced-metrics","title":"3. Advanced Metrics","text":"<ul> <li>Add percentile calculations (P50, P95, P99) if needed</li> <li>Consider adding resource utilization metrics</li> </ul>"},{"location":"adr-enhanced-statistics/#implementation-notes","title":"Implementation Notes","text":""},{"location":"adr-enhanced-statistics/#error-code-enhancements","title":"Error Code Enhancements","text":"<ul> <li><code>ActionException</code>: Add constructor accepting error name (string)</li> <li><code>SqlException</code>: Add constructor accepting error code (string)</li> <li>Update all throwing sites to provide appropriate error identifiers</li> </ul>"},{"location":"adr-enhanced-statistics/#timing-implementation","title":"Timing Implementation","text":"<ul> <li>Wrap action execution with timing measurements</li> <li>Separate SQL execution time from overall action time</li> <li>Use high-resolution clocks for accurate measurements</li> </ul>"},{"location":"adr-enhanced-statistics/#statistics-collection","title":"Statistics Collection","text":"<ul> <li>Replace current <code>successfulActions</code> and <code>failedActions</code> counters in <code>RandomWorker</code></li> <li>Implement statistics collection at the same points where current counters are updated</li> <li>Add reporting method that outputs detailed statistics instead of simple totals</li> </ul> <p>This design provides comprehensive error categorization for known exception types while maintaining simplicity for generic exceptions and avoiding thread safety complexity.</p>"},{"location":"adr-existing-database-support/","title":"ADR: Existing Database Support for StormWeaver","text":""},{"location":"adr-existing-database-support/#status","title":"Status","text":"<p>Proposed - Ready for implementation</p>"},{"location":"adr-existing-database-support/#context","title":"Context","text":"<p>StormWeaver currently assumes it starts with an empty database and builds its metadata from scratch as it creates tables, indexes, and other database objects. This approach works well for stress testing scenarios that start from a clean state, but it limits StormWeaver's ability to test backup/restore scenarios and other operations that require working with existing databases.</p>"},{"location":"adr-existing-database-support/#current-limitation","title":"Current Limitation","text":"<ul> <li>StormWeaver can only work with databases it creates from scratch</li> <li>No support for connecting to existing databases with pre-existing schema</li> <li>Cannot test backup/restore workflows that start with populated databases</li> <li>Limited ability to test database recovery scenarios</li> </ul>"},{"location":"adr-existing-database-support/#use-cases-for-existing-database-support","title":"Use Cases for Existing Database Support","text":"<ol> <li>Backup/Restore Testing: Create a database, populate it, backup, restore, and continue testing within the same StormWeaver run</li> <li>Database Recovery Testing: Test recovery from various failure scenarios during a single test execution</li> <li>Schema Migration Testing: Test schema changes on existing databases within a single test workflow</li> </ol>"},{"location":"adr-existing-database-support/#decision","title":"Decision","text":"<p>We will implement support for initializing StormWeaver's metadata from existing databases by:</p> <ol> <li>Adding Schema Discovery: Query PostgreSQL system catalogs to discover existing schema</li> <li>Implementing Metadata Population: Convert discovered schema into StormWeaver's metadata structures</li> <li>Extending Worker API: Add <code>discover_existing_schema()</code> method to Worker class for initialization</li> <li>Maintaining Backwards Compatibility: Ensure all existing scenarios continue working unchanged</li> <li>Single-Run Scope: Feature designed for use within a single StormWeaver execution only</li> </ol>"},{"location":"adr-existing-database-support/#architecture","title":"Architecture","text":""},{"location":"adr-existing-database-support/#core-components","title":"Core Components","text":""},{"location":"adr-existing-database-support/#1-schemadiscovery-class","title":"1. SchemaDiscovery Class","text":"<pre><code>class SchemaDiscovery {\npublic:\n    explicit SchemaDiscovery(sql_variant::LoggedSQL* connection);\n\n    std::vector&lt;DiscoveredTable&gt; discoverTables();\n    std::vector&lt;DiscoveredColumn&gt; discoverColumns(const std::string&amp; table_name);\n    std::vector&lt;DiscoveredIndex&gt; discoverIndexes(const std::string&amp; table_name);\n    std::vector&lt;DiscoveredConstraint&gt; discoverConstraints(const std::string&amp; table_name);\n    std::vector&lt;DiscoveredPartition&gt; discoverPartitions(const std::string&amp; table_name);\n\nprivate:\n    sql_variant::LoggedSQL* connection_;\n    // SQL queries for system catalog introspection\n};\n</code></pre>"},{"location":"adr-existing-database-support/#2-metadatapopulator-class","title":"2. MetadataPopulator Class","text":"<pre><code>class MetadataPopulator {\npublic:\n    explicit MetadataPopulator(metadata::Metadata&amp; metadata);\n\n    void populateFromExistingDatabase(SchemaDiscovery&amp; discovery);\n\nprivate:\n    metadata::Metadata&amp; metadata_;\n\n    metadata::Table convertCompleteTable(SchemaDiscovery&amp; discovery, const DiscoveredTable&amp; table);\n    metadata::Column convertColumn(const DiscoveredColumn&amp; discovered);\n    metadata::Index convertIndex(const DiscoveredIndex&amp; discovered);\n    metadata::ColumnType mapPostgreSQLType(const std::string&amp; pg_type);\n};\n</code></pre>"},{"location":"adr-existing-database-support/#3-extended-worker-api","title":"3. Extended Worker API","text":"<pre><code>class Worker {\npublic:\n    // Existing constructor unchanged\n    Worker(std::string const &amp;name, sql_connector_t const &amp;sql_connector,\n           WorkloadParams const &amp;config, metadata_ptr metadata);\n\n    // Existing methods unchanged\n    void create_random_tables(std::size_t count);\n    void generate_initial_data();\n\n    // NEW: Discover and populate metadata from existing database\n    void discover_existing_schema();\n\nprivate:\n    bool discoverAndPopulateSchema();\n    // ... existing members\n};\n</code></pre>"},{"location":"adr-existing-database-support/#postgresql-system-catalog-queries","title":"PostgreSQL System Catalog Queries","text":""},{"location":"adr-existing-database-support/#table-discovery","title":"Table Discovery","text":"<pre><code>SELECT \n  c.relname as table_name,\n  c.relkind as table_type,\n  am.amname as access_method,\n  ts.spcname as tablespace,\n  c.relpartbound is not null as is_partition,\n  pt.parttype as partition_type\nFROM pg_class c\nLEFT JOIN pg_am am ON c.relam = am.oid\nLEFT JOIN pg_tablespace ts ON c.reltablespace = ts.oid\nLEFT JOIN pg_partition pt ON c.oid = pt.partrelid\nWHERE c.relkind IN ('r', 'p')\n  AND c.relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')\nORDER BY c.relname;\n</code></pre>"},{"location":"adr-existing-database-support/#column-discovery","title":"Column Discovery","text":"<pre><code>SELECT \n  a.attname as column_name,\n  t.typname as data_type,\n  a.attlen as length,\n  a.atttypmod as type_modifier,\n  a.attnotnull as not_null,\n  a.attnum as ordinal_position,\n  CASE WHEN a.attidentity = 'd' THEN true ELSE false END as is_serial,\n  CASE WHEN a.attgenerated = 's' THEN 'stored'\n       WHEN a.attgenerated = 'v' THEN 'virtual'\n       ELSE 'not_generated' END as generated_type,\n  pg_get_expr(ad.adbin, ad.adrelid) as default_value\nFROM pg_attribute a\nJOIN pg_type t ON a.atttypid = t.oid\nLEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\nWHERE a.attrelid = $1\n  AND a.attnum &gt; 0\n  AND NOT a.attisdropped\nORDER BY a.attnum;\n</code></pre>"},{"location":"adr-existing-database-support/#index-discovery","title":"Index Discovery","text":"<pre><code>SELECT \n  i.relname as index_name,\n  ix.indisunique as is_unique,\n  array_agg(a.attname ORDER BY ix.indkey) as column_names,\n  array_agg(CASE WHEN o.option &amp; 1 = 1 THEN 'desc' ELSE 'asc' END) as orderings\nFROM pg_index ix\nJOIN pg_class i ON ix.indexrelid = i.oid\nJOIN pg_class t ON ix.indrelid = t.oid\nJOIN pg_attribute a ON t.oid = a.attrelid AND a.attnum = ANY(ix.indkey)\nLEFT JOIN unnest(ix.indoption) WITH ORDINALITY AS o(option, pos) ON true\nWHERE ix.indrelid = $1\n  AND NOT ix.indisprimary\nGROUP BY i.relname, ix.indisunique\nORDER BY i.relname;\n</code></pre>"},{"location":"adr-existing-database-support/#primary-key-discovery","title":"Primary Key Discovery","text":"<pre><code>SELECT \n  a.attname as column_name,\n  a.attnum as ordinal_position\nFROM pg_constraint c\nJOIN pg_index i ON c.conindid = i.indexrelid\nJOIN pg_attribute a ON i.indrelid = a.attrelid AND a.attnum = ANY(i.indkey)\nWHERE c.conrelid = $1\n  AND c.contype = 'p'\nORDER BY a.attnum;\n</code></pre>"},{"location":"adr-existing-database-support/#partition-discovery","title":"Partition Discovery","text":"<pre><code>SELECT \n  c.relname as partition_name,\n  pg_get_expr(c.relpartbound, c.oid) as partition_bound\nFROM pg_class c\nWHERE c.relispartition = true\n  AND c.relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')\n  AND c.relname LIKE $1\nORDER BY c.relname;\n</code></pre>"},{"location":"adr-existing-database-support/#type-mapping-strategy","title":"Type Mapping Strategy","text":"<p>PostgreSQL to StormWeaver type mapping: - <code>int4</code>, <code>int8</code>, <code>serial</code>, <code>bigserial</code> \u2192 <code>metadata::ColumnType::INT</code> - <code>char</code>, <code>bpchar</code> \u2192 <code>metadata::ColumnType::CHAR</code> - <code>varchar</code> \u2192 <code>metadata::ColumnType::VARCHAR</code> - <code>text</code> \u2192 <code>metadata::ColumnType::TEXT</code> - <code>float4</code>, <code>float8</code>, <code>numeric</code> \u2192 <code>metadata::ColumnType::REAL</code> - <code>bool</code> \u2192 <code>metadata::ColumnType::BOOL</code> - <code>bytea</code> \u2192 <code>metadata::ColumnType::BYTEA</code></p>"},{"location":"adr-existing-database-support/#configuration-and-usage","title":"Configuration and Usage","text":""},{"location":"adr-existing-database-support/#lua-interface-only-configuration-method","title":"Lua Interface (Only Configuration Method)","text":"<pre><code>-- New: Existing database mode using Worker initialization\nfunction main()\n    local node = stormweaver.create_node(sql_params)\n\n    -- Create a setup worker to discover existing schema\n    local setup_worker = node:make_worker(\"schema_discovery\")\n    setup_worker:discover_existing_schema()  -- NEW method\n\n    -- Continue with normal workload\n    local workload = node:init_random_workload(params)\n    workload:run()\nend\n\n-- Existing scenarios remain unchanged\nfunction main()\n    local node = stormweaver.create_node(sql_params)\n    local workload = node:init_random_workload(params)\n    workload:run()\nend\n</code></pre>"},{"location":"adr-existing-database-support/#error-handling-and-fallback","title":"Error Handling and Fallback","text":"<pre><code>void Worker::discover_existing_schema() {\n    try {\n        SchemaDiscovery discovery(sql_conn.get());\n        auto tables = discovery.discoverTables();\n\n        if (tables.empty()) {\n            spdlog::info(\"No existing tables found, metadata remains empty\");\n            return;\n        }\n\n        MetadataPopulator populator(*metadata);\n        populator.populateFromExistingDatabase(discovery);\n\n        spdlog::info(\"Successfully discovered {} tables from existing database\", tables.size());\n\n    } catch (const std::exception&amp; e) {\n        spdlog::warn(\"Failed to discover existing schema: {}\", e.what());\n        spdlog::info(\"Metadata remains empty, workers will create tables as normal\");\n    }\n}\n</code></pre>"},{"location":"adr-existing-database-support/#consequences","title":"Consequences","text":""},{"location":"adr-existing-database-support/#positive","title":"Positive","text":"<ol> <li>Backup/Restore Testing: Enables comprehensive backup/restore workflow testing</li> <li>Database Recovery Testing: Supports testing recovery from various failure scenarios</li> <li>Backwards Compatibility: Zero breaking changes to existing scenarios</li> <li>Flexible Configuration: Multiple ways to configure existing database mode</li> <li>Robust Error Handling: Graceful fallback to empty database mode on failures</li> <li>Thread Safety: Leverages existing metadata reservation system for safety</li> </ol>"},{"location":"adr-existing-database-support/#negative","title":"Negative","text":"<ol> <li>Implementation Complexity: Adds significant complexity to the codebase</li> <li>PostgreSQL Dependency: Queries are PostgreSQL-specific (consistent with current focus)</li> <li>Maintenance Overhead: New SQL queries and type mappings to maintain</li> <li>Testing Complexity: Requires comprehensive testing of schema discovery logic</li> <li>Single-Run Limitation: Cannot persist schema information between StormWeaver runs</li> </ol>"},{"location":"adr-existing-database-support/#risks-and-mitigations","title":"Risks and Mitigations","text":""},{"location":"adr-existing-database-support/#risk-schema-discovery-failures","title":"Risk: Schema Discovery Failures","text":"<ul> <li>Mitigation: Robust error handling with fallback to empty database mode</li> <li>Monitoring: Comprehensive logging of discovery process</li> </ul>"},{"location":"adr-existing-database-support/#risk-type-mapping-incompatibilities","title":"Risk: Type Mapping Incompatibilities","text":"<ul> <li>Mitigation: Conservative type mapping with explicit error handling</li> <li>Testing: Comprehensive test coverage for all supported PostgreSQL types</li> </ul>"},{"location":"adr-existing-database-support/#risk-thread-safety-issues","title":"Risk: Thread Safety Issues","text":"<ul> <li>Mitigation: Use existing metadata reservation system</li> <li>Testing: Extensive concurrency testing</li> </ul>"},{"location":"adr-existing-database-support/#risk-schema-discovery-overhead","title":"Risk: Schema Discovery Overhead","text":"<ul> <li>Mitigation: Discovery only happens when explicitly called via Worker method</li> <li>Optimization: Discovery is one-time operation during initialization phase</li> </ul>"},{"location":"adr-existing-database-support/#implementation-plan","title":"Implementation Plan","text":""},{"location":"adr-existing-database-support/#phase-1-core-infrastructure","title":"Phase 1: Core Infrastructure","text":"<ol> <li>Implement <code>SchemaDiscovery</code> class with PostgreSQL system catalog queries</li> <li>Implement <code>MetadataPopulator</code> class for type conversion</li> <li>Add <code>Node::initFromExistingDatabase()</code> method</li> <li>Implement basic error handling and fallback</li> </ol>"},{"location":"adr-existing-database-support/#phase-2-worker-integration","title":"Phase 2: Worker Integration","text":"<ol> <li>Add Lua interface for <code>worker:discover_existing_schema()</code></li> <li>Integrate with existing Worker initialization patterns</li> <li>Ensure proper metadata sharing between discovery worker and workload workers</li> </ol>"},{"location":"adr-existing-database-support/#phase-3-comprehensive-testing","title":"Phase 3: Comprehensive Testing","text":"<ol> <li>Unit tests for schema discovery and population</li> <li>Integration tests with various database schemas</li> <li>Regression tests for backwards compatibility</li> <li>Performance benchmarks</li> </ol>"},{"location":"adr-existing-database-support/#phase-4-documentation-and-examples","title":"Phase 4: Documentation and Examples","text":"<ol> <li>Update documentation with new capabilities</li> <li>Create example scenarios for backup/restore testing</li> <li>Add troubleshooting guide for common issues</li> </ol>"},{"location":"adr-existing-database-support/#testing-strategy","title":"Testing Strategy","text":""},{"location":"adr-existing-database-support/#unit-tests","title":"Unit Tests","text":"<ul> <li><code>SchemaDiscovery</code> class with mock database connections</li> <li><code>MetadataPopulator</code> class with various schema combinations</li> <li>Type mapping functions for all supported PostgreSQL types</li> <li>Error handling and fallback scenarios</li> </ul>"},{"location":"adr-existing-database-support/#integration-tests","title":"Integration Tests","text":"<ul> <li>Real PostgreSQL database with various schema configurations</li> <li>Backup/restore workflow testing</li> <li>Concurrent access during schema discovery</li> <li>Performance impact measurement</li> </ul>"},{"location":"adr-existing-database-support/#regression-tests","title":"Regression Tests","text":"<ul> <li>All existing scenarios continue working unchanged</li> <li>Metadata consistency between empty and existing database modes</li> <li>Thread safety under concurrent load</li> </ul>"},{"location":"adr-existing-database-support/#acceptance-criteria","title":"Acceptance Criteria","text":"<ol> <li>Functional Requirements</li> <li>[ ] Can discover existing tables, columns, indexes, and constraints</li> <li>[ ] Correctly maps PostgreSQL types to StormWeaver types</li> <li>[ ] Supports partitioned tables and range partitioning</li> <li>[ ] Handles primary keys and unique constraints</li> <li> <p>[ ] Gracefully handles schema discovery failures</p> </li> <li> <p>Non-Functional Requirements</p> </li> <li>[ ] Zero breaking changes to existing scenarios</li> <li>[ ] Thread-safe metadata population</li> <li>[ ] Comprehensive error handling and logging</li> <li>[ ] Performance impact &lt; 5% for existing workflows</li> <li> <p>[ ] Clear documentation and examples</p> </li> <li> <p>Quality Requirements</p> </li> <li>[ ] 95%+ unit test coverage for new code</li> <li>[ ] All existing tests continue passing</li> <li>[ ] Performance benchmarks within acceptable limits</li> <li>[ ] Security review of SQL queries completed</li> </ol>"},{"location":"adr-existing-database-support/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr-existing-database-support/#alternative-1-node-based-discovery","title":"Alternative 1: Node-based Discovery","text":"<p>Implement schema discovery as a Node method instead of Worker method. - Pros: Centralized initialization logic - Cons: Breaks existing initialization patterns, requires new API surface</p>"},{"location":"adr-existing-database-support/#alternative-2-automatic-discovery","title":"Alternative 2: Automatic Discovery","text":"<p>Automatically detect existing schema on first connection. - Pros: No explicit configuration needed - Cons: Unexpected behavior changes, potential performance impact</p>"},{"location":"adr-existing-database-support/#alternative-3-configuration-based-discovery","title":"Alternative 3: Configuration-based Discovery","text":"<p>Use command-line or configuration files to enable discovery. - Pros: External configuration control - Cons: Complicates testing, affects existing test suites</p>"},{"location":"adr-existing-database-support/#implementation-notes","title":"Implementation Notes","text":""},{"location":"adr-existing-database-support/#thread-safety-considerations","title":"Thread Safety Considerations","text":"<ul> <li>Schema discovery occurs before workers start, avoiding concurrent access</li> <li>Metadata population uses existing reservation system for thread safety</li> <li>Discovery process is atomic - either fully succeeds or falls back to empty mode</li> </ul>"},{"location":"adr-existing-database-support/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Schema discovery is one-time cost during initialization</li> <li>Discovered metadata is cached for duration of test run</li> <li>Fallback to empty mode has zero performance impact</li> </ul>"},{"location":"adr-existing-database-support/#monitoring-and-observability","title":"Monitoring and Observability","text":"<ul> <li>Comprehensive logging of discovery process</li> <li>Metrics for discovery success/failure rates</li> <li>Performance metrics for discovery duration</li> <li>Schema complexity metrics (table count, column count, etc.)</li> </ul>"},{"location":"adr-existing-database-support/#future-enhancements","title":"Future Enhancements","text":""},{"location":"adr-existing-database-support/#multi-schema-support","title":"Multi-Schema Support","text":"<p>Extend to support multiple PostgreSQL schemas beyond 'public'.</p>"},{"location":"adr-existing-database-support/#schema-validation","title":"Schema Validation","text":"<p>Compare discovered schema against expected schema for validation testing.</p>"},{"location":"adr-existing-database-support/#cross-database-support","title":"Cross-Database Support","text":"<p>Extend schema discovery to support other database systems (MySQL, Oracle, etc.).</p>"},{"location":"adr-existing-database-support/#selective-schema-discovery","title":"Selective Schema Discovery","text":"<p>Allow filtering of specific tables or schema elements during discovery.</p>"},{"location":"adr-existing-database-support/#references","title":"References","text":"<ul> <li>PostgreSQL System Catalogs Documentation</li> <li>StormWeaver Metadata System Documentation</li> <li>StormWeaver Architecture Overview</li> </ul>"},{"location":"building/","title":"Building from source","text":""},{"location":"building/#getting-the-sources","title":"Getting the sources","text":"<p>StormWeaver uses git submodules. These are not included in the tarballs generated by GitHub. To get the sources, use <code>git clone --recursive</code>, or use <code>git clone</code> and initialize the submodules in a separate command:</p> <pre><code>git clone --recursive https://github.com/Percona-Lab/stormweaver.git\n</code></pre>"},{"location":"building/#installing-dependencies","title":"Installing dependencies","text":"<p>The build process only requires two dependencies (other than <code>git</code>):</p> <ul> <li>A modern C++ compiler, such as GCC or Clang</li> <li>Conan 2, to download and build third-party libraries</li> </ul> <p>The build process also uses CMake and Ninja, but these will be installed by Conan if not present on the system.</p>"},{"location":"building/#conan-profile","title":"Conan profile","text":"<p>After installing Conan 2 (using the instructions at https://docs.conan.io/2/installation.html), you also need to set up a profile.</p> <p>A default profile can be created using the following command:</p> <pre><code>conan profile detect\n</code></pre> <p>The default profile usually selects an older C++ standard, while StormWeaver uses C++23. This can be changed by editing <code>~/.conan2/profiles/default</code> and setting <code>compiler.cppstd</code> to <code>23</code>.</p>"},{"location":"building/#building","title":"Building","text":"<p>The following command builds both StormWeaver and all of its <code>conan</code> managed dependencies:</p> <pre><code>conan build . --build=missing --settings=build_type=&lt;Debug/Release&gt;\n</code></pre> <p>During development, when the dependencies are already installed and only the main sources have to be rebuilt, the following commands provide a quicker result:</p> <pre><code># or conan-release\ncmake --build --target install --preset conan-debug\n</code></pre> <p>or with older CMake versions, which do not support this option:</p> <pre><code># or Release\ncd build/Debug\nninja install\n</code></pre>"},{"location":"building/#advanced-build-options","title":"Advanced build options","text":"<p>StormWeaver can be built with various sanitizers for debugging purposes. These can be enabled in the <code>conan build</code> command with various options, for example to build with the address (asan) and undefined behavior (ubsan) sanitizers:</p> <pre><code>conan build . --build=missing --settings=build_type=&lt;Debug/Release&gt; -o '&amp;:asan=True' -o '&amp;:ubsan=True'\n</code></pre> <p>Similarly, <code>msan</code> and <code>tsan</code> are also supported.</p> <p>Note</p> <p>Not all sanitizers can be combined together in a single build. While the above example with <code>asan</code> and <code>ubsan</code> works, other combinations can result in either a build failure or false positives in the report.</p>"},{"location":"code-architecture/","title":"Code architecture","text":""},{"location":"config-parameters/","title":"Configuration Parameters","text":"<p>StormWeaver supports configuration through multiple layers with a clear precedence order: Environment Variables &gt; Command Line Arguments &gt; TOML Configuration File &gt; Hardcoded Defaults.</p> <p>Note</p> <p>Configuration parameters are parsed by Lua scenario scripts. The C++ runner only passes the command-line parameters to the scenario, and provides an API for accessing all configuration options.</p> <p>Custom (external) scenario files might work differently.</p>"},{"location":"config-parameters/#toml-configuration-file","title":"TOML Configuration File","text":"<p>The main configuration is stored in <code>config/stormweaver.toml</code>. You can specify a different config file using the <code>-c/--config</code> command-line option.</p>"},{"location":"config-parameters/#default-configuration-section","title":"Default Configuration Section","text":"<pre><code>[default]\npgroot = \"\"             # PostgreSQL installation directory path\ndatadir_root = \"datadirs\"   # Root directory for PostgreSQL data directories\nport_start = 15432      # Starting port number for PostgreSQL instances\nport_end = 15531        # Ending port number for PostgreSQL instances\n</code></pre>"},{"location":"config-parameters/#configuration-parameters_1","title":"Configuration Parameters","text":""},{"location":"config-parameters/#pgroot","title":"pgroot","text":"<ul> <li>Type: String</li> <li>Default: <code>\"\"</code> (empty string)</li> <li>Purpose: Path to the PostgreSQL installation directory</li> <li>Override: Can be overridden by <code>--install_dir</code> command-line option or <code>PGROOT</code> environment variable</li> <li>Example: <code>pgroot = \"/usr/lib/postgresql/16\"</code></li> </ul>"},{"location":"config-parameters/#datadir_root","title":"datadir_root","text":"<ul> <li>Type: String  </li> <li>Default: <code>\"datadirs\"</code></li> <li>Purpose: Root directory where PostgreSQL data directories will be created</li> <li>Example: <code>datadir_root = \"/tmp/stormweaver_data\"</code></li> </ul>"},{"location":"config-parameters/#port_start","title":"port_start","text":"<ul> <li>Type: Integer</li> <li>Default: <code>15432</code></li> <li>Purpose: Starting port number for PostgreSQL instances (avoids conflicts with system PostgreSQL)</li> <li>Example: <code>port_start = 20000</code></li> </ul>"},{"location":"config-parameters/#port_end","title":"port_end","text":"<ul> <li>Type: Integer</li> <li>Default: <code>15531</code></li> <li>Purpose: Ending port number for PostgreSQL instances (defines available port range)</li> <li>Example: <code>port_end = 20099</code></li> </ul>"},{"location":"config-parameters/#command-line-arguments","title":"Command-Line Arguments","text":"<p>StormWeaver accepts the following command-line arguments:</p>"},{"location":"config-parameters/#required-arguments","title":"Required Arguments","text":""},{"location":"config-parameters/#scenario","title":"scenario","text":"<p><pre><code>stormweaver scenarios/basic.lua\n</code></pre> - Purpose: Path to the Lua scenario file to execute - Type: Positional argument (first argument)</p>"},{"location":"config-parameters/#optional-arguments","title":"Optional Arguments","text":""},{"location":"config-parameters/#-c-config","title":"-c, --config","text":"<p><pre><code>stormweaver -c /path/to/config.toml scenarios/basic.lua\nstormweaver --config custom-config.toml scenarios/basic.lua\n</code></pre> - Purpose: Specify configuration file path - Default: <code>\"config/stormweaver.toml\"</code> - Type: String</p>"},{"location":"config-parameters/#-i-install_dir","title":"-i, --install_dir","text":"<p><pre><code>stormweaver -i /usr/lib/postgresql/16 scenarios/basic.lua\nstormweaver --install_dir /opt/postgres scenarios/basic.lua\n</code></pre> - Purpose: PostgreSQL installation directory (overrides config file and environment variable) - Default: <code>\"\"</code> (uses config file value) - Type: String</p>"},{"location":"config-parameters/#-include","title":"--include","text":"<p><pre><code>stormweaver --include /path/to/scripts --include /another/path scenarios/basic.lua\n</code></pre> - Purpose: Add directories to Lua package search path - Default: <code>\"\"</code> (empty) - Type: String (can be specified multiple times)</p>"},{"location":"config-parameters/#example-usage","title":"Example Usage","text":"<pre><code># Basic usage\nstormweaver scenarios/basic.lua\n\n# With custom config and PostgreSQL installation\nstormweaver -c myconfig.toml -i /usr/lib/postgresql/16 scenarios/basic.lua\n\n# With additional Lua script directories\nstormweaver --include /my/scripts scenarios/basic.lua\n</code></pre>"},{"location":"config-parameters/#environment-variables","title":"Environment Variables","text":""},{"location":"config-parameters/#pgroot_1","title":"PGROOT","text":"<p><pre><code>export PGROOT=\"/usr/lib/postgresql/16\"\nstormweaver scenarios/basic.lua\n</code></pre> - Purpose: Override PostgreSQL installation directory - Precedence: Takes precedence over TOML config but not command-line <code>--install_dir</code> - Type: String</p>"},{"location":"config-parameters/#generic-environment-access","title":"Generic Environment Access","text":"<p>Lua scripts can access any environment variable using the <code>getenv()</code> function: <pre><code>local value = getenv(\"MY_VARIABLE\", \"default_value\")\n</code></pre></p>"},{"location":"config-parameters/#build-time-configuration","title":"Build-Time Configuration","text":""},{"location":"config-parameters/#cmake-variables","title":"CMake Variables","text":""},{"location":"config-parameters/#sanitizer-options","title":"Sanitizer Options","text":"<p><pre><code>cmake -DWITH_ASAN=ON -DWITH_UBSAN=ON ..\n</code></pre> - WITH_ASAN: Enable Address Sanitizer (default: OFF) - WITH_UBSAN: Enable Undefined Behavior Sanitizer (default: OFF) - WITH_TSAN: Enable Thread Sanitizer (default: OFF) - WITH_MSAN: Enable Memory Sanitizer (default: OFF)</p>"},{"location":"config-parameters/#test-configuration","title":"Test Configuration","text":"<p><pre><code>cmake -DTEST_PG_DIR=/usr/lib/postgresql/16 ..\n</code></pre> - TEST_PG_DIR: PostgreSQL installation directory for testing - Default: Auto-detected from common locations or empty - Purpose: Required for SQL integration tests</p>"},{"location":"config-parameters/#compiler-options","title":"Compiler Options","text":"<p><pre><code>cmake -DSTRICT_FLAGS=OFF -DSTRICT_CPU=ON ..\n</code></pre> - STRICT_FLAGS: Enable strict compiler warnings (default: ON) - STRICT_CPU: Optimize for current CPU architecture (default: OFF)</p>"},{"location":"config-parameters/#conan-build-options","title":"Conan Build Options","text":"<p><pre><code>conan build . -o '&amp;:asan=True' -o '&amp;:ubsan=True'\n</code></pre> - asan: Address sanitizer (default: False) - ubsan: Undefined behavior sanitizer (default: False) - tsan: Thread sanitizer (default: False) - msan: Memory sanitizer (default: False)</p>"},{"location":"config-parameters/#default-postgresql-settings","title":"Default PostgreSQL Settings","text":"<p>When StormWeaver creates PostgreSQL instances, it applies these default settings:</p> <pre><code>listen_addresses = '*'\nlogging_collector = on\nlog_statement = ALL\nlog_directory = 'logs'\nlog_filename = 'server.log'\nlog_min_messages = info\nunix_socket_directories = sock\n</code></pre> <p>These can be modified in scenarios using the <code>add_config()</code> method:</p> <pre><code>pg:add_config({\n  max_connections = \"200\",\n  shared_buffers = \"256MB\"\n})\n</code></pre>"},{"location":"config-parameters/#lua-package-path","title":"Lua Package Path","text":"<p>StormWeaver automatically extends the Lua package path with: - <code>scripts/</code> - Helper functions and utilities - <code>scripts_3p/</code> - Third-party Lua modules - Current working directory - Any directories specified via <code>--include</code></p> <p>This allows scenarios to use <code>require()</code> to load modules from these locations.</p>"},{"location":"extensibility-workflow/","title":"Extensibility Workflow","text":"<p>This guide covers advanced development workflows for extending StormWeaver, focusing on the action registry system and Lua C++ API extensions.</p>"},{"location":"extensibility-workflow/#action-registry-system","title":"Action Registry System","text":"<p>The action registry is at the core of StormWeaver's randomized testing framework. It manages a collection of linearly weighted actions that are randomly selected and executed by worker threads.</p> <p>During the random selection each action is added to a pool multiple times based on its weight (1 = only once, 10 - 10 entries, and so on), and then one entry in the pool is selected randomly.</p>"},{"location":"extensibility-workflow/#understanding-the-action-architecture","title":"Understanding the Action Architecture","text":""},{"location":"extensibility-workflow/#core-components","title":"Core Components","text":"<p>Action Interface <pre><code>class Action {\npublic:\n  virtual void execute(metadata::Metadata &amp;metaCtx, ps_random &amp;rand,\n                       sql_variant::LoggedSQL *connection) const = 0;\n};\n</code></pre></p> <p>All actions must implement this interface with these key principles: - Stateless: Actions should be stateless to enable retry logic - Thread-safe: Multiple workers execute actions concurrently - Metadata-aware: Actions interact with shared database schema metadata</p> <p>Actions are expected to throw a <code>RuntimeException</code> (preferably <code>ActionException</code>) on failure.</p> <p>ActionFactory Structure <pre><code>struct ActionFactory {\n  std::string name;        // Unique identifier\n  action_build_t builder;  // Factory function\n  std::size_t weight;      // Probability weight\n};\n</code></pre></p> <p>ActionRegistry Operations - <code>insert()</code>: Add new actions - <code>remove()</code>: Remove actions by name - <code>get()</code>: Retrieve action factory for modification - <code>lookupByWeightOffset()</code>: Random weighted selection</p>"},{"location":"extensibility-workflow/#creating-custom-actions","title":"Creating Custom Actions","text":""},{"location":"extensibility-workflow/#1-simple-custom-sql-actions","title":"1. Simple Custom SQL Actions","text":"<p>The easiest way to add custom actions is through Lua scripts:</p> <pre><code>function setup_custom_actions()\n  local registry = defaultActionRegistry()\n\n  -- Simple SQL action (no parameters)\n  registry:makeCustomSqlAction(\"vacuum_db\", \"VACUUM;\", 10)\n\n  -- Table-based SQL action (uses {table} placeholder)\n  registry:makeCustomTableSqlAction(\"analyze_table\", \"ANALYZE {table};\", 5)\n\n  -- Custom pg_tde actions\n  registry:makeCustomSqlAction(\"tde_set_key\", \n    \"SELECT pg_tde_set_server_key('test_key','reg_file','false');\", 15)\nend\n</code></pre>"},{"location":"extensibility-workflow/#2-complex-custom-actions-in-c","title":"2. Complex Custom Actions in C++","text":"<p>For more complex logic, create custom action classes:</p> <p>Step 1: Define Action Class <pre><code>// File: libstormweaver/include/action/my_action.hpp\n#pragma once\n#include \"action/action.hpp\"\n\nnamespace action {\n\nstruct CustomConfig {\n    std::string prefix;\n};\n\nclass MyCustomAction : public Action {\npublic:\n\n  MyCustomAction(CustomConfig const &amp;config);\n\n  void execute(metadata::Metadata &amp;metaCtx, ps_random &amp;rand,\n               sql_variant::LoggedSQL *connection) const override;\n\nprivate:\n  CustomConfig config_;\n};\n\n} // namespace action\n</code></pre></p> <p>Note</p> <p>The above example showcases a completely new action type in a new source file. When appropriate, edit existing files, such as ddl.hpp/cpp or dml.hpp/cpp. When editing existing files, it is usually better to extend the existing configuration struct instead of defining a new struct.</p> <p>Step 2: Implement Action Logic <pre><code>// File: libstormweaver/src/action/my_action.cpp\n#include \"action/my_action.hpp\"\n#include \"action/helper.hpp\"\n\nnamespace action {\n\nMyCustomAction::MyCustomAction(CustomConfig const &amp;config) : config_(config) {}\n\nvoid MyCustomAction::execute(metadata::Metadata &amp;metaCtx, ps_random &amp;rand,\n                             sql_variant::LoggedSQL *connection) const {\n  // 1. Find a suitable table\n  auto table = find_random_table(metaCtx, rand);\n  if (!table) {\n    throw ActionException(\"No tables available\");\n  }\n\n  // 2. Generate dynamic SQL\n  std::string sql = fmt::format(\"SELECT COUNT(*) FROM {} WHERE id LIKE '{}%'\", \n                               table-&gt;name, config_.prefix);\n\n  // 3. Execute query and handle results\n  auto result = connection-&gt;executeQuery(sql);\n  if (!result.success) {\n    throw ActionException(\"Query failed: \" + result.query);\n  }\n}\n\n} // namespace action\n</code></pre></p> <p>Step 3: Add Configuration to AllConfig</p> <p>When creating custom actions with their own configuration, you must add the configuration to the <code>AllConfig</code> structure:</p> <pre><code>// File: libstormweaver/include/action/all.hpp\n// Add your custom config to the AllConfig struct:\n\nstruct AllConfig {\n  DdlConfig ddl;\n  DmlConfig dml;\n  CustomConfig custom;        // Add this line for your custom configuration\n  // ... other existing configs\n};\n</code></pre> <p>The <code>AllConfig</code> structure is used to pass all configuration parameters to action factories. Without adding your custom configuration here, your action factory won't be able to access the configuration parameters it needs.</p> <p>Step 4: Register Action <pre><code>// File: libstormweaver/src/action/action_registry.cpp\n#include \"action/my_action.hpp\"\n\n// Declare a factory in the anonymous namespace:\nActionFactory myCustomAction{\n    \"my_custom_action\",\n    [](AllConfig const &amp;config) {\n      return std::make_unique&lt;MyCustomAction&gt;(config.custom);\n    },\n    25  // Weight\n};\n\n// Add it to the default registry in initializeDefaultRegistry\nar.insert(myCustomAction);\n</code></pre></p>"},{"location":"extensibility-workflow/#working-with-composite-actions","title":"Working with Composite Actions","text":"<p>Composite actions allow you to combine multiple operations.</p> <p>For examples and possibilities, see <code>action/composite.hpp</code> and <code>action/action_registry.cpp</code>.</p>"},{"location":"extensibility-workflow/#runtime-action-management","title":"Runtime Action Management","text":"<p>Modify action registry during scenario execution:</p> <pre><code>function customize_workload(node)\n  local registry = node:possibleActions()\n\n  -- Remove problematic actions\n  registry:remove(\"drop_table\")\n  registry:remove(\"drop_partition\")\n\n  -- Increase data manipulation frequency\n  registry:get(\"insert_some_data\").weight = 200\n  registry:get(\"update_one_row\").weight = 150\n\n  -- Add scenario-specific actions\n  registry:makeCustomTableSqlAction(\"reindex_table\", \n    \"REINDEX TABLE {table};\", 20)\n\n  -- Add checkpoint action\n  registry:makeCustomSqlAction(\"checkpoint\", \"CHECKPOINT;\", 5)\nend\n</code></pre>"},{"location":"extensibility-workflow/#extending-the-lua-c-api","title":"Extending the Lua C++ API","text":""},{"location":"extensibility-workflow/#understanding-the-binding-system","title":"Understanding the Binding System","text":"<p>StormWeaver uses Sol2 to bind C++ classes and functions to Lua. All bindings are defined in <code>libstormweaver/src/scripting/luactx.cpp</code>.</p>"},{"location":"extensibility-workflow/#adding-new-global-functions","title":"Adding New Global Functions","text":"<p>Step 1: Implement C++ Function <pre><code>// In luactx.cpp or separate file\nstd::string get_database_version(sql_variant::LoggedSQL* conn) {\n  auto result = conn-&gt;executeQuery(\"SELECT version()\");\n  if (result.success &amp;&amp; result.data.nextRow()) {\n    return result.data.field(1);\n  }\n  return \"unknown\";\n}\n</code></pre></p> <p>Step 2: Bind to Lua <pre><code>// In LuaContext::LuaContext() constructor\nluaState[\"get_database_version\"] = &amp;get_database_version;\n</code></pre></p> <p>Step 3: Use in Lua Scripts <pre><code>function check_database_version(worker)\n  local conn = worker:sql_connection()\n  local version = get_database_version(conn)\n  info(\"Database version: \" .. version)\nend\n</code></pre></p>"},{"location":"extensibility-workflow/#adding-new-classes","title":"Adding New Classes","text":"<p>Step 1: Define C++ Class <pre><code>// File: libstormweaver/include/utils/database_info.hpp\nclass DatabaseInfo {\npublic:\n  DatabaseInfo(sql_variant::LoggedSQL* conn);\n\n  std::string getVersion() const;\n  int getConnectionCount() const;\n  std::vector&lt;std::string&gt; getTableNames() const;\n\nprivate:\n  sql_variant::LoggedSQL* connection_;\n};\n</code></pre></p> <p>Step 2: Implement Class Methods <pre><code>// File: libstormweaver/src/utils/database_info.cpp\nDatabaseInfo::DatabaseInfo(sql_variant::LoggedSQL* conn) : connection_(conn) {}\n\nstd::string DatabaseInfo::getVersion() const {\n  auto result = connection_-&gt;executeQuery(\"SELECT version()\");\n  // Implementation...\n}\n\nstd::vector&lt;std::string&gt; DatabaseInfo::getTableNames() const {\n  auto result = connection_-&gt;executeQuery(\n    \"SELECT tablename FROM pg_tables WHERE schemaname = 'public'\");\n  std::vector&lt;std::string&gt; tables;\n  while (result.data.nextRow()) {\n    tables.push_back(result.data.field(1));\n  }\n  return tables;\n}\n</code></pre></p> <p>Step 3: Bind Class to Lua <pre><code>// In LuaContext::LuaContext() constructor\nauto db_info_usertype = luaState.new_usertype&lt;DatabaseInfo&gt;(\n    \"DatabaseInfo\", \n    sol::constructors&lt;DatabaseInfo(sql_variant::LoggedSQL*)&gt;());\n\ndb_info_usertype[\"getVersion\"] = &amp;DatabaseInfo::getVersion;\ndb_info_usertype[\"getConnectionCount\"] = &amp;DatabaseInfo::getConnectionCount;\ndb_info_usertype[\"getTableNames\"] = &amp;DatabaseInfo::getTableNames;\n</code></pre></p> <p>Step 4: Use in Lua Scripts <pre><code>function analyze_database(worker)\n  local conn = worker:sql_connection()\n  local dbinfo = DatabaseInfo(conn)\n\n  info(\"Database version: \" .. dbinfo:getVersion())\n  info(\"Connection count: \" .. dbinfo:getConnectionCount())\n\n  local tables = dbinfo:getTableNames()\n  for i, table_name in ipairs(tables) do\n    info(\"Table \" .. i .. \": \" .. table_name)\n  end\nend\n</code></pre></p>"},{"location":"extensibility-workflow/#extending-existing-classes","title":"Extending Existing Classes","text":"<p>Add new methods to existing classes:</p> <pre><code>// Add to Worker bindings\nworker_usertype[\"getTableCount\"] = [](Worker&amp; self) -&gt; int {\n  return self.metadata().tableCount();\n};\n\nworker_usertype[\"createSpecialTable\"] = [](Worker&amp; self, std::string const&amp; name) {\n  // Custom table creation logic\n};\n</code></pre>"},{"location":"extensibility-workflow/#advanced-api-patterns","title":"Advanced API Patterns","text":""},{"location":"extensibility-workflow/#callback-support","title":"Callback Support","text":"<pre><code>// Support Lua callbacks in C++ code\n// Note: Lua callbacks implemented this way are not thread-safe,\n// only use them for immediate use\n// For more advanced multithreaded use, see the LuaCallback class\nauto lua_callback = luaState.get&lt;sol::function&gt;(\"my_callback\");\nif (lua_callback.valid()) {\n  sol::protected_function_result result = lua_callback(arg1, arg2);\n  if (!result.valid()) {\n    sol::error err = result;\n    spdlog::error(\"Lua callback failed: {}\", err.what());\n  }\n}\n</code></pre>"},{"location":"extensibility-workflow/#property-access","title":"Property Access","text":"<pre><code>// Add properties to existing classes\npostgres_usertype[\"data_directory\"] = sol::property(\n  &amp;process::Postgres::getDataDirectory,\n  &amp;process::Postgres::setDataDirectory\n);\n</code></pre>"},{"location":"extensibility-workflow/#error-handling","title":"Error Handling","text":"<pre><code>// Proper exception handling for Lua bindings\nluaState[\"risky_function\"] = [](int value) -&gt; int {\n  try {\n    if (value &lt; 0) {\n      throw std::invalid_argument(\"Value must be non-negative\");\n    }\n    return value * 2;\n  } catch (std::exception const&amp; e) {\n    throw sol::error(e.what());\n  }\n};\n</code></pre>"},{"location":"extensibility-workflow/#best-practices","title":"Best Practices","text":""},{"location":"extensibility-workflow/#action-development","title":"Action Development","text":"<ol> <li>Thread Safety: Use proper locking when accessing shared resources</li> <li>Error Handling: Use <code>ActionException</code> for action-specific errors</li> <li>Metadata Consistency: Always use the reservation pattern for metadata updates</li> <li>Testing: Create unit and integration tests for custom actions</li> </ol>"},{"location":"extensibility-workflow/#api-extension","title":"API Extension","text":"<ol> <li>Memory Management: Use smart pointers and RAII principles</li> <li>Exception Safety: Wrap C++ exceptions for Lua consumption</li> <li>Documentation: Update lua-cpp-reference.md for new API additions</li> <li>Backward Compatibility: Consider the impact on existing scripts</li> </ol>"},{"location":"extensibility-workflow/#debugging","title":"Debugging","text":"<ol> <li>Logging: Use the existing spdlog infrastructure for consistent logging across C++ and Lua</li> <li>Error Messages: Provide clear, actionable error messages</li> <li>Stack Traces: Sol2 provides good error reporting for the Lua/C++ boundary</li> <li>Testing: Use sanitizers (ASAN, TSAN) during development</li> </ol>"},{"location":"lua-cpp-reference/","title":"Lua C++ API Reference","text":"<p>This is a reference of the Lua API implemented directly in C++.</p> <p>Note</p> <p>Lua bindings are defined in <code>libstormweaver/src/scripting/luactx.cpp</code></p>"},{"location":"lua-cpp-reference/#global-functions","title":"Global functions","text":""},{"location":"lua-cpp-reference/#sleep","title":"sleep","text":"<pre><code>sleep(milliseconds)\n</code></pre> <p>Sleeps for the specified time</p>"},{"location":"lua-cpp-reference/#defaultactionregistry","title":"defaultActionRegistry","text":"<pre><code>a = defaultActionRegistry()\n</code></pre> <p>Returns a modifiable reference to the default action registry</p>"},{"location":"lua-cpp-reference/#initpostgresdatadir","title":"initPostgresDatadir","text":"<p>Creates a new postgres data directory</p> <pre><code>pg = initPostgresDatadir('pg/install/dir', 'new/data/dir')\n</code></pre>"},{"location":"lua-cpp-reference/#initbasebackupfrom","title":"initBasebackupFrom","text":"<p>Creates a new postgres data directory as a backup of a running postgres instance.</p> <pre><code>replica = initBasebackupFrom('pg/install/dir', 'new/data/dir', primaryNode) -- allows any number of additional parameters, added to the basebackup command line\n</code></pre>"},{"location":"lua-cpp-reference/#debug","title":"debug","text":"<p>Writes a debug message to the log</p>"},{"location":"lua-cpp-reference/#info","title":"info","text":"<p>Writes an info message to the log</p>"},{"location":"lua-cpp-reference/#warning","title":"warning","text":"<p>Writes a warning message to the log</p>"},{"location":"lua-cpp-reference/#getenv","title":"getenv","text":"<p>Returns the value of an environment variable, or a default.</p> <pre><code>e = getenv(\"NAME\", \"default\")\n</code></pre>"},{"location":"lua-cpp-reference/#setup_node_pg","title":"setup_node_pg","text":"<p>Configures the connection parameters to a PostgreSQL installation.</p> <pre><code>return setup_node_pg({\n  host = \"localhost\",\n  port = 5432,\n  user = \"username\",\n  password = \"\",\n  database = \"stormweaver\",\n  on_connect = conn_callback,\n})\n</code></pre>"},{"location":"lua-cpp-reference/#actionfactory","title":"ActionFactory","text":"<p>Used to create a specific action, stored in an <code>ActionRegistry</code></p>"},{"location":"lua-cpp-reference/#weight","title":"weight","text":"<p>A property representing the chance/weight of an action</p> <pre><code>action.weight = action.weight + 13;\n</code></pre>"},{"location":"lua-cpp-reference/#actionregistry","title":"ActionRegistry","text":"<p>Represents a set of actions executed by worker(s).</p>"},{"location":"lua-cpp-reference/#remove","title":"remove","text":"<p>Removes the action with the name from the registry.</p> <pre><code>ar:remove(\"alter_table\")\n</code></pre>"},{"location":"lua-cpp-reference/#insert","title":"insert","text":"<p>Inserts the specified ActionFactory to the registry. This function requires a specific Factory, which can be retrieved from another Registry using the <code>get</code> function.</p> <pre><code>ar1:insert(ar2:get(\"truncate\"))\n</code></pre>"},{"location":"lua-cpp-reference/#has","title":"has","text":"<p>Tells if the registry has a factory with the specified name.</p> <pre><code>if ar:has(\"alter_table\") then\n  --- ...\nend\n</code></pre>"},{"location":"lua-cpp-reference/#makecustomsqlaction","title":"makeCustomSqlAction","text":"<p>Creates a new custom SQL action with a specific query and weight.</p> <pre><code>ar:makeCustomSqlAction(\"checkpoint\", \"CHECKPOINT;\", 1)\n</code></pre>"},{"location":"lua-cpp-reference/#makecustomtablesqlaction","title":"makeCustomTableSqlAction","text":"<p>Creates a new custom SQL action related to a table, with a specific weight. The <code>{table}</code> expression in the SQL command is replaced with a randomly choosen table. Can be specified multiple times, and the same table will be used each time.</p> <pre><code>ar:makeCustomTableSqlAction(\"truncate_table\", \"TRUNCATE {table};\", 2)\n</code></pre>"},{"location":"lua-cpp-reference/#get","title":"get","text":"<p>Returns a reference to the factory with the specified name.</p> <pre><code>ar1:insert(ar2:get(\"truncate\"))\n</code></pre>"},{"location":"lua-cpp-reference/#use","title":"use","text":"<p>Overwrites the contents of the registry using the specified other registry. The two registries will be equal after executing this function.</p> <pre><code>ar1:use(ar2)\n</code></pre>"},{"location":"lua-cpp-reference/#default-actions","title":"Default Actions","text":"<p>The default action registry includes the following built-in actions available for randomized testing:</p>"},{"location":"lua-cpp-reference/#table-management-actions","title":"Table Management Actions","text":"<ul> <li><code>create_normal_table</code> - Creates a regular table with random columns and with some initial data</li> <li><code>create_partitioned_table</code> - Creates a partitioned table with random columns and with some initial data</li> <li><code>drop_table</code> - Drops a randomly selected existing table</li> <li><code>alter_table</code> - Performs random alterations to a randomly selected existing table</li> <li><code>rename_table</code> - Renames a randomly selected table</li> </ul>"},{"location":"lua-cpp-reference/#index-management-actions","title":"Index Management Actions","text":"<ul> <li><code>create_index</code> - Creates an index on a randomly selected table</li> <li><code>drop_index</code> - Drops a randomly selected existing index</li> </ul>"},{"location":"lua-cpp-reference/#partition-management-actions","title":"Partition Management Actions","text":"<ul> <li><code>create_partition</code> - Creates a partition for an existing randomly selected partitioned table</li> <li><code>drop_partition</code> - Drops a randomly selected partition</li> </ul>"},{"location":"lua-cpp-reference/#data-manipulation-action","title":"Data Manipulation Action","text":"<ul> <li><code>insert_some_data</code> - Inserts random data into a randomly selected existing table (multiple rows)</li> <li><code>delete_some_data</code> - Deletes random rows from a randomly selected existing table</li> <li><code>update_one_row</code> - Updates a random row in a a randomly selected existing table</li> </ul>"},{"location":"lua-cpp-reference/#example-customizing-default-actions","title":"Example: Customizing Default Actions","text":"<pre><code>-- This function modifies the actual default ActionRegistry\n-- Every call after this modification will use the modified default settings\nfunction customize_default_actions()\n  local registry = defaultActionRegistry()\n\n  -- Remove actions we don't want\n  registry:remove(\"drop_table\")\n  registry:remove(\"drop_partition\")\n\n  -- Adjust weights for remaining actions\n  registry:get(\"insert_some_data\").weight = 20  -- Make inserts more likely\n  registry:get(\"create_index\").weight = 5       -- Make index creation less likely\n\n  -- Add custom actions\n  registry:makeCustomSqlAction(\"vacuum\", \"VACUUM;\", 2)\n  registry:makeCustomTableSqlAction(\"analyze_table\", \"ANALYZE {table};\", 3)\nend\n</code></pre>"},{"location":"lua-cpp-reference/#fs","title":"fs","text":"<p>A collection of filesystem operations.</p>"},{"location":"lua-cpp-reference/#is_directory","title":"is_directory","text":"<p>Returns true if a directory with the specified name exists</p> <pre><code>if fs.is_directory('foo/bar') then\n  -- ...\nend\n</code></pre>"},{"location":"lua-cpp-reference/#copy_directory","title":"copy_directory","text":"<p>Copies the directory recursively</p> <pre><code>fs.copy_directory('from', 'to')\n</code></pre>"},{"location":"lua-cpp-reference/#create_directory","title":"create_directory","text":"<p>Creates a new directory recursively</p> <pre><code>fs.create_directory('path/to/the/new/dir')\n</code></pre>"},{"location":"lua-cpp-reference/#delete_directory","title":"delete_directory","text":"<p>Deletes the specified directory</p> <pre><code>fs.delete_directory('foo/bar')\n</code></pre>"},{"location":"lua-cpp-reference/#loggedsql","title":"LoggedSQL","text":"<p>A class representing a database connection</p>"},{"location":"lua-cpp-reference/#execute_query","title":"execute_query","text":"<p>Executes a SQL query and returns a QueryResult object containing the result set. This function can execute any type of SQL statement and provides access to result data for queries that return results (like SELECT).</p> <pre><code>conn.execute_query(\"CREATE EXTENSION pg_tde;\")\n</code></pre>"},{"location":"lua-cpp-reference/#queryresult","title":"QueryResult","text":"<p>A class representing the result of a SQL query execution.</p>"},{"location":"lua-cpp-reference/#success","title":"success","text":"<p>A boolean property indicating whether the query executed successfully.</p> <pre><code>if result.success then\n  -- Query executed successfully\nend\n</code></pre>"},{"location":"lua-cpp-reference/#query","title":"query","text":"<p>A string property containing the original SQL query that was executed.</p> <pre><code>print(\"Executed query: \" .. result.query)\n</code></pre>"},{"location":"lua-cpp-reference/#data","title":"data","text":"<p>A QuerySpecificResult object containing the actual result data, only available when success is true.</p> <pre><code>if result.success then\n  local resultSet = result.data\nend\n</code></pre>"},{"location":"lua-cpp-reference/#queryspecificresult","title":"QuerySpecificResult","text":"<p>A class representing the data returned from a successful SQL query.</p>"},{"location":"lua-cpp-reference/#numrows","title":"numRows","text":"<p>A property containing the number of rows returned by the query.</p> <pre><code>local rowCount = result.data.numRows\n</code></pre>"},{"location":"lua-cpp-reference/#numfields","title":"numFields","text":"<p>A property containing the number of columns (fields) in the result set.</p> <pre><code>local columnCount = result.data.numFields\n</code></pre>"},{"location":"lua-cpp-reference/#nextrow","title":"nextRow","text":"<p>Advances to the next row in the result set. Returns true if there is a next row, false if at the end. Must be called before accessing field data for each row.</p> <pre><code>while result.data:nextRow() do\n  -- Process current row\nend\n</code></pre>"},{"location":"lua-cpp-reference/#rowview","title":"RowView","text":"<p>A class representing the current row in a result set, accessed through QuerySpecificResult.</p>"},{"location":"lua-cpp-reference/#field","title":"field","text":"<p>Returns the value of the specified field in the current row. Can be accessed only by column index (1-indexed).</p> <pre><code>local value = result.data:field(1)  -- Get first column (1-indexed)\n</code></pre>"},{"location":"lua-cpp-reference/#numfields_1","title":"numFields","text":"<p>Returns the number of fields (columns) in the current row.</p> <pre><code>local columnCount = result.data:numFields()\n</code></pre>"},{"location":"lua-cpp-reference/#example-processing-query-results","title":"Example: Processing Query Results","text":"<pre><code>function process_table_data(worker)\n  local conn = worker:sql_connection()\n  local result = conn:execute_query(\"SELECT id, name, value FROM test_table\")\n\n  if result.success then\n    info(\"Query returned \" .. result.data.numRows .. \" rows\")\n\n    while result.data:nextRow() do\n      local id = result.data:field(1)      -- By index\n      local name = result.data:field(\"name\")  -- By column name\n      local value = result.data:field(3)\n\n      info(\"Row: id=\" .. id .. \", name=\" .. name .. \", value=\" .. value)\n    end\n  else\n    warning(\"Query failed: \" .. result.query)\n  end\nend\n</code></pre>"},{"location":"lua-cpp-reference/#node","title":"Node","text":"<p>A class representing a database server, created using the <code>setupPgNode</code> global function.</p>"},{"location":"lua-cpp-reference/#init","title":"init","text":"<p>Intended for node initialization, takes a callback that receives as a Worker as the single parameter.</p> <pre><code>function setup_fun(worker)\n    worker:create_random_tables(5)\nend\npgm.primaryNode:init(setup_fun)\n</code></pre>"},{"location":"lua-cpp-reference/#initrandomworkload","title":"initRandomWorkload","text":"<p>Creates a new random workload setup with the given parameters.</p> <p>It expects a WorkloadParams object:</p> <pre><code>params = WorkloadParams()\nparams.duration_in_seconds = 10\nparams.number_of_workers = 5\nnode:initRandomWorkload(params)\n</code></pre> <p>Supported parameters:</p> <ul> <li><code>duration_in_seconds</code>: how long to run the workload (default: 60)</li> <li><code>number_of_workers</code>: how many workers to use in the workload (default 5)</li> <li><code>repeat_times</code>: how many times to repeat the entire workload (default: 10)</li> <li><code>max_reconnect_attempts</code>: maximum number of reconnection attempts when a worker loses connection (default: 5)</li> </ul>"},{"location":"lua-cpp-reference/#possibleactions","title":"possibleActions","text":"<p>Returns a reference to the action registry associated with the node. This is a copy made at the time of creating the node, and can be modified separately. Will be copied into the workload when one is created using <code>initRandomWorkload</code>.</p> <pre><code>a = node:possibleActions()\n</code></pre>"},{"location":"lua-cpp-reference/#make_worker","title":"make_worker","text":"<pre><code>worker = node:make_worker(\"initialization\")\n</code></pre> <p>Creates a standalone Worker instance for the node with the specified log name. Useful for database initialization or other non-workload operations.</p>"},{"location":"lua-cpp-reference/#workloadparams","title":"WorkloadParams","text":"<p>A class for configuring workload parameters. Can be created and configured before passing to <code>initRandomWorkload</code>.</p>"},{"location":"lua-cpp-reference/#constructor","title":"Constructor","text":"<pre><code>params = WorkloadParams()\n</code></pre> <p>Creates a new WorkloadParams object with default values.</p>"},{"location":"lua-cpp-reference/#properties","title":"Properties","text":"<pre><code>params.duration_in_seconds = 30      -- How long each workload iteration runs\nparams.number_of_workers = 8         -- Number of concurrent worker threads\nparams.repeat_times = 5              -- Number of times to repeat the workload\nparams.max_reconnect_attempts = 3    -- Max reconnection attempts per worker\n</code></pre>"},{"location":"lua-cpp-reference/#postgres","title":"Postgres","text":"<p>A class used to manage a Postgres installation/datadir.</p> <p>An instance of this class can be created with the global functions <code>initPostgresDatadir</code> and <code>initBasebackupFrom</code>.</p>"},{"location":"lua-cpp-reference/#start","title":"start","text":"<p>Starts the server, returns true if succeeds.</p> <pre><code>pg1:start()                                           -- Normal start\npg1:start(\"/usr/bin/valgrind\", {\"--leak-check=full\"}) -- Start under valgrind\n</code></pre> <p>The optional wrapper and wrapperArgs parameters allow running PostgreSQL through external tools like debuggers or profilers.</p> <p>Note</p> <p>The wrapper parameter doesn't take <code>$PATH</code> into account, it requires a full filename</p>"},{"location":"lua-cpp-reference/#stop","title":"stop","text":"<p>Stops the server Has a parameter, the graceful wait period - after that, it executes kill9.</p> <pre><code>pg1:stop(10)\n</code></pre>"},{"location":"lua-cpp-reference/#restart","title":"restart","text":"<p>Restarts (stops and starts) the server, returns true if succeeds. Has a parameter, the graceful wait period - after that, it executes kill9.</p> <pre><code>pg1:restart(10)                                            -- Normal restart with 10s grace period\npg1:restart(5, \"/usr/bin/valgrind\", {\"--leak-check=full\"}) -- Restart under valgrind\n</code></pre> <p>The optional wrapper and wrapperArgs parameters allow running PostgreSQL through external tools like debuggers or profilers on restart.</p> <p>Note</p> <p>The wrapper parameter doesn't take <code>$PATH</code> into account, it requires a full filename</p>"},{"location":"lua-cpp-reference/#kill9","title":"kill9","text":"<p>Kills the server without waiting for it to stop.</p> <pre><code>pg1:kill9()\n</code></pre>"},{"location":"lua-cpp-reference/#basebackup","title":"basebackup","text":"<p>Performs a base backup of the database to the specified directory.</p> <p>The first parameter is an array of strings that gets added to the PostgreSQL <code>pg_basebackup</code> command. The <code>-h</code>, <code>-p</code> options are automatically added based on the server configuration.</p> <pre><code>-- Basic backup\npg1:basebackup({\"-D\", \"backup_dir\", \"-U\", \"stormweaver\", \"-c\", \"fast\"})\n\n-- Incremental backup\npg1:basebackup({\"-D\", \"backup_dir\", \"-U\", \"stormweaver\", \"-c\", \"fast\", \"-i\", \"prev_backup/backup_manifest\"})\n</code></pre>"},{"location":"lua-cpp-reference/#createdb","title":"createdb","text":"<p>Creates a database with the specified name.</p> <pre><code>pg1:createdb(\"foo\")\n</code></pre>"},{"location":"lua-cpp-reference/#dropdb","title":"dropdb","text":"<p>Drops the database with the specified name.</p> <pre><code>pg1:dropdb(\"foo\")\n</code></pre>"},{"location":"lua-cpp-reference/#createuser","title":"createuser","text":"<p>Creates a user.</p> <p>The first parameter is the name of the user, and the second parameter is an array of strings that gets added to the postgres <code>createuser</code> command.</p> <pre><code>pg1:createuser(\"stormweaver\", {\"-s\"})\n</code></pre>"},{"location":"lua-cpp-reference/#is_running","title":"is_running","text":"<p>Returns true if the server is running.</p> <pre><code>if pg1:is_running() then\n -- ...\nend\n</code></pre>"},{"location":"lua-cpp-reference/#serverport","title":"serverPort","text":"<p>Returns the port the server is using</p> <pre><code>p = pg1:serverPort()\n</code></pre>"},{"location":"lua-cpp-reference/#datadir","title":"dataDir","text":"<p>Returns the data directory path as a string</p> <pre><code>path = pg1:dataDir()\n</code></pre>"},{"location":"lua-cpp-reference/#is_ready","title":"is_ready","text":"<p>Returns true if the server is ready to accept connections.</p> <pre><code>if pg1:is_ready then\n  -- ...\nend\n</code></pre>"},{"location":"lua-cpp-reference/#wait_ready","title":"wait_ready","text":"<p>Waits up to the specified time in seconds, or until the server is ready.</p> <pre><code>if not pg1:wait_ready(20) then\n  -- ...\nend\n</code></pre>"},{"location":"lua-cpp-reference/#add_config","title":"add_config","text":"<p>Appends the specified settings to the postgres configuration.</p> <p>As Postgres only uses the last entry if the same setting is specified multiple times, this can also be used to modify existing settings.</p> <pre><code>pg1:add_config({\n  logging_collector = \"on\",\n  log_directory = \"'logs'\",\n  log_filename = \"'server.log'\",\n  log_min_messages = \"'info'\",\n})\n</code></pre>"},{"location":"lua-cpp-reference/#add_hba","title":"add_hba","text":"<p>Adds an entry to the <code>pg_hba.conf</code>.</p> <pre><code>pg1:add_hba(\"host\", \"replication\", \"repuser\", \"127.0.0.1/32\", \"trust\")\n</code></pre>"},{"location":"lua-cpp-reference/#backgroundthread","title":"BackgroundThread","text":"<p>Allows scripts to run something in the background.</p> <p>For a more detailed example, see the section in the Lua Examples page.</p>"},{"location":"lua-cpp-reference/#run","title":"run","text":"<p>Starts a background thread, using the specified logfile name and lua function.</p>"},{"location":"lua-cpp-reference/#join","title":"join","text":"<p>Waits until the background thread completes.</p>"},{"location":"lua-cpp-reference/#send","title":"send","text":"<p>Sends the specified string to the background thread.</p>"},{"location":"lua-cpp-reference/#receive","title":"receive","text":"<p>Receives a single string from the background thread - blocks and waits if it didn't send anything yet.</p>"},{"location":"lua-cpp-reference/#receiveifany","title":"receiveIfAny","text":"<p>Receives a single string from the background thread, if it sent anything.</p>"},{"location":"lua-cpp-reference/#commqueue","title":"CommQueue","text":"<p>A communication queue for inter-thread message passing. Available in background thread contexts for communication with the main thread.</p>"},{"location":"lua-cpp-reference/#send_1","title":"send","text":"<pre><code>-- In background thread\ncommQueue:send(\"message to main thread\")\n</code></pre> <p>Sends a string message to the main thread.</p>"},{"location":"lua-cpp-reference/#receive_1","title":"receive","text":"<pre><code>-- In background thread\nlocal message = commQueue:receive()\n</code></pre> <p>Receives a string message from the main thread. Blocks until a message is available.</p>"},{"location":"lua-cpp-reference/#receiveifany_1","title":"receiveIfAny","text":"<pre><code>-- In background thread\nlocal message = commQueue:receiveIfAny()\nif message then\n  -- Process message\nend\n</code></pre> <p>Receives a string message from the main thread if one is available, otherwise returns nil.</p>"},{"location":"lua-cpp-reference/#backgroundprocess","title":"BackgroundProcess","text":"<p>A class for managing external processes in the background.</p>"},{"location":"lua-cpp-reference/#start_1","title":"start","text":"<p>Starts a new background process with the specified command and arguments.</p> <pre><code>-- Static method to start a new process\nlocal proc = BackgroundProcess.start(\"logname\", \"/usr/bin/command\", \"arg1\", \"arg2\")\n</code></pre> <p>Parameters: - <code>logname</code> (string): Name for the log file (logs will be written to <code>logs/{logname}.log</code>) - <code>command</code> (string): Full path to the executable to run - <code>...</code> (variadic): Command line arguments to pass to the process</p> <p>Returns: - A BackgroundProcess object that can be used to control the process</p>"},{"location":"lua-cpp-reference/#waituntilexits","title":"waitUntilExits","text":"<p>Waits for the process to complete and returns the exit status.</p> <pre><code>local success = proc:waitUntilExits()\nif success then\n  info(\"Process completed successfully\")\nelse\n  warning(\"Process failed\")\nend\n</code></pre> <p>Returns: - <code>true</code> if the process exited with status 0, <code>false</code> otherwise</p>"},{"location":"lua-cpp-reference/#kill","title":"kill","text":"<p>Sends a signal to the process to terminate it.</p> <pre><code>proc:kill(9)  -- Send SIGKILL\n</code></pre> <p>Parameters: - <code>signal</code> (number): The signal number to send (e.g., 9 for SIGKILL, 15 for SIGTERM)</p>"},{"location":"lua-cpp-reference/#running","title":"running","text":"<p>Checks if the process is currently running.</p> <pre><code>if proc:running() then\n  info(\"Process is still running\")\nelse\n  info(\"Process has finished\")\nend\n</code></pre> <p>Returns: - <code>true</code> if the process is running, <code>false</code> if it has finished</p>"},{"location":"lua-cpp-reference/#example-running-external-commands","title":"Example: Running External Commands","text":"<pre><code>function run_pg_dump()\n  local proc = BackgroundProcess.start(\"pg_dump\", \"/usr/bin/pg_dump\", \"-h\", \"localhost\", \"-p\", \"5432\", \"mydb\")\n\n  if proc:waitUntilExits() then\n    info(\"Database dump completed successfully\")\n  else\n    warning(\"Database dump failed\")\n  end\nend\n\nfunction run_with_timeout()\n  local proc = BackgroundProcess.start(\"long_task\", \"/usr/bin/sleep\", \"30\")\n\n  -- Wait for 10 seconds\n  local start_time = os.time()\n  while proc:running() and (os.time() - start_time) &lt; 10 do\n    sleep(1000)  -- Check every second\n  end\n\n  if proc:running() then\n    warning(\"Process taking too long, killing it\")\n    proc:kill(15)  -- Send SIGTERM\n    sleep(2000)    -- Give it time to clean up\n    if proc:running() then\n      proc:kill(9)  -- Force kill if still running\n    end\n  end\nend\n</code></pre>"},{"location":"lua-cpp-reference/#randomworker","title":"RandomWorker","text":"<p>Represents a randomized worker. It supports the same functions as the <code>Worker</code>, with the following additions:</p>"},{"location":"lua-cpp-reference/#possibleactions_1","title":"possibleActions","text":"<p>Returns a reference to the action registry associated with the specfic worker. This can be used to modify the actions executed by a single Worker, without affecting other Workers.</p> <pre><code>workload:worker(3):possibleActions():remove(\"alter_table\")\n</code></pre>"},{"location":"lua-cpp-reference/#worker","title":"Worker","text":"<p>A (non randomized) worker that can be used for initialization and other database related things.</p>"},{"location":"lua-cpp-reference/#create_random_tables","title":"create_random_tables","text":"<p>Creates a specified number of tables according to the DDL configuration.</p> <p>Currently the DDL configuration can't be modified.</p> <pre><code>worker:create_random_tables(5)\n</code></pre>"},{"location":"lua-cpp-reference/#discover_existing_schema","title":"discover_existing_schema","text":"<p>Discovers and populates the metadata system with the existing database schema.</p> <p>This function scans the connected database and builds StormWeaver's internal metadata representation based on the actual database structure (tables, columns, indexes, etc.).</p> <pre><code>worker:discover_existing_schema()\n</code></pre>"},{"location":"lua-cpp-reference/#reset_metadata","title":"reset_metadata","text":"<p>Clears all metadata, resetting it to an empty state.</p> <p>This function removes all stored table and schema information from StormWeaver's internal metadata system.</p> <pre><code>worker:reset_metadata()\n</code></pre>"},{"location":"lua-cpp-reference/#validate_metadata","title":"validate_metadata","text":"<p>Validates that the current metadata accurately reflects the actual database schema.</p> <p>This function compares the current metadata against a fresh schema discovery from the database. If validation fails, it writes debug files to the <code>logs/</code> directory containing both the original and newly discovered metadata for comparison.</p> <p>Returns <code>true</code> if metadata matches the database schema, <code>false</code> otherwise.</p> <pre><code>if worker:validate_metadata() then\n  info(\"Metadata is consistent with database schema\")\nelse\n  warning(\"Metadata validation failed - check logs/ directory for debug files\")\nend\n</code></pre>"},{"location":"lua-cpp-reference/#sql_connection","title":"sql_connection","text":"<p>Returns the SQL connection (LoggedSQL) of the worker, which can be used to execute SQL statements directly.</p> <pre><code>sql = worker:sql_connection()\n</code></pre>"},{"location":"lua-cpp-reference/#calculate_database_checksums","title":"calculate_database_checksums","text":"<p>Calculates SHA-256 checksums for all metadata tables in the database and writes the results to a specified file.</p> <p>This function iterates through all tables tracked in the metadata system, calculates a checksum of their contents using SHA-256 hashing, and outputs the results in CSV format. The checksums are deterministic and will produce the same result for identical table contents.</p> <pre><code>worker:calculate_database_checksums(\"checksums.csv\")\n</code></pre> <p>Parameters: - <code>filename</code> (string): Path to the output file where checksums will be written</p> <p>Output Format: The output file contains CSV data with the following columns: - <code>table_name</code>: Name of the table - <code>checksum</code>: SHA-256 hash of the table contents (64-character hex string) - <code>row_count</code>: Number of rows in the table</p> <p>Example output: <pre><code>table_name,checksum,row_count\nusers,a1b2c3d4e5f6789012345678901234567890abcdef1234567890abcdef123456,1500\nproducts,e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855,0\norders,f7a8b9c0d1e2f3456789012345678901234567890abcdef1234567890abcdef12,2300\n</code></pre></p> <p>Note: Empty tables will have the SHA-256 hash of an empty string (<code>e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855</code>).</p> <p>Error Handling: - Throws a Lua error if the file cannot be opened for writing - Throws a Lua error if a table query fails - Throws a Lua error if row count retrieval fails</p>"},{"location":"lua-cpp-reference/#workload","title":"Workload","text":"<p>Represents a testrun, it is created by <code>Node</code> using <code>initRandomWorkload</code>.</p>"},{"location":"lua-cpp-reference/#run_1","title":"run","text":"<p>Starts the workload.</p> <p>The workload is executed in the background, this functions returns immediately after starting. This allows the script to modify the workload, or interact with the SQL servers while the workload is running.</p> <pre><code>workload:run()\n</code></pre>"},{"location":"lua-cpp-reference/#wait_completion","title":"wait_completion","text":"<p>Waits until the currently running workload is completed.</p> <pre><code>workload:wait_completion()\n</code></pre>"},{"location":"lua-cpp-reference/#worker_1","title":"worker","text":"<p>Returns the Worker with the specified index.</p> <p>Indexing starts with 1.</p> <pre><code>workload:worker(3)\n</code></pre>"},{"location":"lua-cpp-reference/#worker_count","title":"worker_count","text":"<p>Returns the number of workers.</p> <pre><code>workload:worker_count()\n</code></pre>"},{"location":"lua-cpp-reference/#reconnect_workers","title":"reconnect_workers","text":"<p>Reconnects any workers that lots their connection because of a restart.</p>"},{"location":"randomized-testing-concepts/","title":"Randomized testing concepts","text":"<p>A main goal of StormWeaver is to enable scripted randomized testing.</p> <p>This feature uses the following parts:</p>"},{"location":"randomized-testing-concepts/#workload","title":"Workload","text":"<p>A workload is a randomized test execution.</p> <p>It is executed with some time limit, using some number of <code>Worker</code>s.</p>"},{"location":"randomized-testing-concepts/#worker","title":"Worker","text":"<p>A Worker is a thread executing <code>Action</code>s.</p> <p>A randomized thread usually runs one or more workers, and each worker repeatedly chooses a random action and executes it, until the <code>time limit</code> is reached.</p>"},{"location":"randomized-testing-concepts/#action","title":"Action","text":"<p>An Action is something executed during the test, usually in the form of one or more SQL statements.</p> <p>For example:</p> <ul> <li>Creating a table</li> <li>Dropping a table</li> <li>Altering a table</li> <li>Inserting some data</li> <li>....</li> </ul> <p>While there are some actions implemented in the C++ framework, it also makes it possible to define custom actions using an <code>ActionRegistry</code></p>"},{"location":"randomized-testing-concepts/#actionregistry","title":"ActionRegistry","text":"<p>An ActionRegistry is a collection of possible actions, and a definition of how these actions can be constructed. Other than the action definition itself, each Action in a Registry also has a weight, which determines the chance of its execution.</p> <p>For each random action selection, the sum of all weights is calculated, and then a random number is chosen in the (0, sumOfWeights) range. Then the action is determined based on where this number lands in the list of actions.</p>"},{"location":"scripting-architecture/","title":"Scripting architecture","text":"<p>StormWeaver relies on scripts written in Lua for test scenarios and utility code for the scenarios.</p> <p>The C++ code is just a framework that provides a helper architecture and executes a main Lua script. If that script does nothing, the program just exits after startup.</p> <p>There are also helper functions/classes written in Lua, using the C++ code. The goal of these is to simplify the development of test scenarios, while also allowing easy modification without rebuilding the main executable.</p>"},{"location":"scripting-architecture/#folder-structure","title":"Folder structure","text":"<p>Lua scripts are stored in three directories:</p> <ul> <li><code>scenarios</code> is intended for specific test scenarios</li> <li><code>scripts</code> is intended for helper functions/classes usable by multiple scenarios</li> <li><code>scripts_3p/</code> contains third-party Lua libraries using git submodules</li> </ul>"},{"location":"scripting-architecture/#module-search-path","title":"Module Search Path","text":"<p>The following directories are automatically added to the Lua package search path:</p> <ul> <li><code>scripts/</code> - Helper functions and utilities (relative to executable and working directory)</li> <li><code>scripts_3p/</code> - Third-party Lua modules (relative to executable and working directory)</li> <li>Current working directory</li> </ul>"},{"location":"scripting-architecture/#third-party-libraries","title":"Third-party libraries","text":"<p>StormWeaver automatically loads several third-party Lua libraries and makes them available to scripts and scenarios:</p>"},{"location":"scripting-architecture/#automatically-available-libraries","title":"Automatically Available Libraries","text":"<ul> <li>toml - TOML parsing library, automatically injected into the global namespace (no require needed)</li> </ul>"},{"location":"scripting-architecture/#manually-loaded-libraries","title":"Manually Loaded Libraries","text":"<ul> <li>argparse - Command-line argument parsing, available via <code>require(\"argparse\")</code></li> <li>inspect.lua - Object inspection and pretty-printing, available via <code>require(\"inspect\")</code></li> <li>lfs - Lua File System library for advanced file operations, available via <code>require(\"lfs\")</code></li> </ul>"},{"location":"scripting-architecture/#usage-examples","title":"Usage Examples","text":"<pre><code>-- TOML is automatically available globally\nlocal config_data = toml.parse(config_text)\n\n-- Other libraries require explicit loading\nlocal lfs = require(\"lfs\")\nlocal inspect = require(\"inspect\")\nlocal argparse = require(\"argparse\")\n\n-- Access files from the automatic search paths\nrequire(\"common\")     -- Loads scripts/common.lua\nrequire(\"PgManager\")  -- Loads scripts/PgManager.lua\n</code></pre>"},{"location":"scripting-architecture/#c-binding","title":"C++ binding","text":"<p>StormWeaver includes several classes/functions implemented in C++, which are usable in Lua scripts. The complete list of these functions is available in the Lua C++ reference.</p>"},{"location":"scripting-architecture/#scenario-configuration-and-entry-point","title":"Scenario configuration and entry point","text":""},{"location":"scripting-architecture/#script-entry-point","title":"Script Entry Point","text":"<p>Every scenario script must define a <code>main</code> function that serves as the entry point:</p> <pre><code>require(\"common\")\n\nfunction main(argv)\n  -- argv contains all command-line arguments passed to the script\n  -- argv[1] is the script filename\n  -- argv[2], argv[3], etc. are additional arguments\n\n  local args = argparser:parse(argv)  -- Parse using argparse\n  local conffile = parse_config(args) -- loads stormweaver.toml based on the --config argument\n  -- Your scenario logic here\nend\n</code></pre> <p>The <code>main</code> function receives command-line arguments and is called automatically when the script is executed.</p>"},{"location":"scripting-architecture/#argument-parsing","title":"Argument Parsing","text":"<p>The <code>argparse</code> library is included, and the C++ runner forwards all arguments to the script, including the scenario filename.</p> <p>The Lua helpers already create a default parser using the global variable <code>argparser</code>, which includes handling the common arguments, so scenarios only have to set up additional scenario-specific arguments.</p>"},{"location":"scripting-architecture/#example-adding-custom-arguments","title":"Example: Adding Custom Arguments","text":"<pre><code>require(\"common\")\n\n-- Add scenario-specific arguments (can be done at global scope)\nargparser:option(\"-t --timeout\", \"Test timeout in seconds\", 30)\nargparser:flag(\"--skip-cleanup\", \"Skip cleanup after test\")\n\nfunction main(argv)\n  local args = argparser:parse(argv)\n\n  local timeout = args.timeout\n  local skip_cleanup = args.skip_cleanup\n\n  info(\"Running with timeout: \" .. timeout .. \" seconds\")\n  if skip_cleanup then\n    info(\"Cleanup will be skipped\")\n  end\n\n  -- Rest of scenario logic\nend\n</code></pre>"},{"location":"scripting-architecture/#multi-threaded-structure","title":"Multi-threaded structure","text":"<p>StormWeaver is a multithreaded, concurrent test framework, while Lua is a single-threaded scripting language. To make the two work together, it uses multiple Lua instances:</p> <ul> <li>There's one \"main\" instance used for the scenario startup and setup</li> <li>There's one instance per worker thread when running workloads</li> <li>And any of the above threads also might start background workers, resulting in additional Lua threads</li> </ul> <p>The main thread and background workers are Lua-first: there's a Lua function (<code>main</code> in case of the main thread, user specified for background workers) that gets executed, and when this function ends, the thread also exits.</p> <p>The worker threads are however C++-first: the random workload is generated by a C++ runner, and it only executes Lua functions when it is necessary.</p>"},{"location":"scripting-architecture/#limitations","title":"Limitations","text":"<p>To ensure that all threads have access to the same functions, the scenario file is loaded for all Lua states.</p> <p>This results in the following limitations:</p> <ul> <li>the scenario script, and included other scripts get processed multiple times</li> <li>anything that is executed directly by the script will be executed by all threads</li> <li>while global variables will be available in all threads, their values will be different and won't be synced</li> </ul> <p>In line with this, it is recommended that script/scenario files:</p> <ul> <li>shouldn't rely on mutable global variables</li> <li>shouldn't execute code directly in the source file, instead everything should go into the <code>main</code> function or other callable functions</li> <li>should define functions and constants at global scope, but defer execution to the <code>main</code> function</li> </ul>"},{"location":"scripting-examples/","title":"Scripting examples","text":""},{"location":"scripting-examples/#minimal-scenario","title":"Minimal scenario","text":"<pre><code>require(\"common\")\n\nfunction setup_tables(worker)\n    worker:create_random_tables(5)\nend\n\nfunction main(argv)\n    args = argparser:parse(argv)\n    conffile = parse_config(args)\n    pgconfig = PgConf.new(conffile[\"default\"])\n\n    pgm = PgManager.new(pgconfig)\n    pgm:setupAndStartPrimary()\n    pgm.primaryNode:init(setup_tables)\n\n    pg1 = pgm:get(1)\n\n    t1 = pgm.primaryNode:initRandomWorkload({ run_seconds = 20, worker_count = 5 })\n    t1:run()\n    t1:wait_completion()\nend\n</code></pre>"},{"location":"scripting-examples/#custom-arguments","title":"Custom arguments","text":"<p>A complete documentation for <code>argparse</code> is available at https://argparse.readthedocs.io/</p> <pre><code>-- could also be in main\nargparser:option(\"-f --foo\", \"A sample option.\", \"bar\")\n\nfunction main(argv)\n    args = argparser:parse(argv)\n    info(\"Foo: \" .. inspect(args[\"foo\"]))\nend\n</code></pre>"},{"location":"scripting-examples/#simple-postgres-manager","title":"Simple postgres manager","text":"<p>It is easy and simple to set up (replicated) PostgreSQL using <code>PgManager</code>:</p> <pre><code>pgconfig = PgConf.new(conffile[\"default\"])\n\npgm = PgManager.new(pgconfig)\npgm:setupAndStartPrimary()\npgm:setupAndStartAReplica()\n-- can start additional replicas\n\nprimary = pgm:get(1)\nreplica = pgm:get(2)\n-- ...\n</code></pre>"},{"location":"scripting-examples/#background-threads","title":"Background threads","text":"<p>The following example shows the background thread functionality:</p> <pre><code>-- global variables shouldn't be used: the values can be different in every thread\nvar = \"foo\";\n\n-- functions defined in lua can be called in any thread\nfunction dep()\n    info(\"From dep(): var=\" .. var)\nend\n\nfunction bg_thread()\n    info(\"From bgt()\")\n    dep()\n\n    for i=1,10 do\n        -- the receive, receiveIfAny and send functions are special to background threads, \n        -- and used for communication with the creator thread\n        msg = receive();\n\n        info(\"Received message: \" .. msg);\n\n        if msg == \"exit\" then\n            break;\n        end;\n    end\nend\n\nfunction main(argv)\n\n    info(\"Starting background thread...\")\n\n    -- won't be reflected in the thread, do not depend on global state\n    var = \"bar\"\n\n    task = BackgroundThread.run(\"bglog\", \"bg_thread\")\n\n    info(\"While background thread running ... \")\n\n    task:send(\"hey!\")\n    task:send(\"foo!\")\n    task:send(\"bar!\")\n\n    info(\"While background thread still running ... \")\n\n    task:send(\"exit\")\n\n    task:join()\n\n    info(\"All done\")\n\nend\n</code></pre>"}]}